<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: black;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .glass-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        .glass-effect {
            /* Base styles */
            background: rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);

            /* Glossy border effect */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 1px solid rgba(255, 255, 255, 0.15);

            /* Enhanced shadow effects */
            box-shadow:
                0 4px 32px 0 rgba(0, 0, 0, 0.37),
                inset 0 0 32px 0 rgba(255, 255, 255, 0.02),
                0 0 64px 0 rgba(0, 0, 0, 0.2);

            /* Subtle glossy gradient overlay */
            background-image: linear-gradient(
                125deg,
                rgba(255, 255, 255, 0.03) 0%,
                rgba(255, 255, 255, 0.01) 40%,
                transparent 100%
            );

            padding: 40px;
            margin-top: 30px;
            width: 500px;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            position: relative;
            overflow: hidden;
        }

        /* Glossy shine effect */
        .glass-effect::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 0%,
                rgba(255, 255, 255, 0.03) 30%,
                rgba(255, 255, 255, 0.05) 40%,
                rgba(255, 255, 255, 0.03) 50%,
                transparent 100%
            );
            transform: rotate(-45deg);
            pointer-events: none;
            animation: shine 10s infinite linear;
            opacity: 0.5;
        }

        @keyframes shine {
            0% {
                transform: translateY(-100%) rotate(-45deg);
            }
            100% {
                transform: translateY(100%) rotate(-45deg);
            }
        }

        .glass-effect.expanded {
            opacity: 1;
        }
        .terminal-content {
            display: none;
            line-height: 1.6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .terminal-content.active {
            display: block;
            opacity: 1;
        }
        .terminal-title {
            color: #00ff00;
            font-weight: bold;
            margin-bottom: 20px;
            white-space: nowrap;
            overflow: hidden;
        }
        .terminal-text {
            color: #00ff00;
            white-space: pre-line;
            visibility: hidden;
            position: relative;
            z-index: 1;
        }
        .terminal-text.typing {
            visibility: visible;
        }
        .cursor {
            display: inline-block;
            width: 8px;
            height: 15px;
            background: #00ff00;
            animation: blink 1s infinite;
            vertical-align: middle;
            margin-left: 5px;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .bottom-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 50px;
            z-index: 1000;
            white-space: nowrap;
        }
        .text-content {
            color: rgba(180, 190, 220, 1);
            font-family: Arial;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-size: 24px;
        }
        .text-content span + span {
            margin-left: 0.5em;
        }
        .menu {
            display: flex;
            gap: 20px;
            font-family: Arial;
        }
        .menu a {
            color: rgba(180, 190, 220, 0.8);
            text-decoration: none;
            font-size: 14px;
            transition: color 0.3s ease;
            cursor: pointer;
        }
        .menu a:hover {
            color: rgba(180, 190, 220, 1);
        }
    </style>
</head>
<body>
    <canvas id="gridCanvas"></canvas>
    <div class="glass-container">
        <div class="glass-effect">
            <div id="homeContent" class="terminal-content active">
                <div class="terminal-title">> About Us_<span class="cursor"></span></div>
                <div class="terminal-text">Modern Code develops innovative and user-friendly apps for the App Store.

We are dedicated to creating high-quality applications that enhance the mobile experience for our users.</div>
            </div>
            <div id="privacyContent" class="terminal-content">
                <div class="terminal-title">> PRIVACY POLICY_<span class="cursor"></span></div>
                <div class="terminal-text">The developer of this app respects your privacy with a strict zero data collection policy.

This app does not:
- transmit any data
- connect to any server
- connect to the internet
- collect any information
- track you
- collect any data whatsoever
- collect personal data
- collect aggregate data
- collect anonymous data

Simply put, you can use the app with 100% privacy.

> Contact Developer_
jake@moderncode.ai</div>
            </div>
            <div id="contactContent" class="terminal-content">
                <div class="terminal-title">> Contact Us_<span class="cursor"></span></div>
                <div class="terminal-text">If you have any questions, comments, or concerns, please feel free to reach out to us:

> Email: jake@moderncode.ai

We value your feedback and will do our best to respond to your inquiries in a timely manner.</div>
            </div>
        </div>
    </div>
    <div class="bottom-container">
        <div class="text-content">
            <span>MODERN</span><span>CODE</span>
        </div>
        <nav class="menu">
            <a onclick="showContent('home')">About Us</a>
            <a onclick="showContent('privacy')">Privacy Policy</a>
            <a onclick="showContent('contact')">Contact Us</a>
        </nav>
    </div>
    <script>
        // Typing animation function
function typeText(element, text, speed = 10) {
    // Store the original text with proper line breaks
    const lines = text.split('\n');
    element.innerHTML = '';
    element.classList.add('typing');

    let lineIndex = 0;
    let charIndex = 0;

    function type() {
        if (lineIndex < lines.length) {
            // For new lines after the first line, add a line break
            if (charIndex === 0) {
                // Only add line break if not the first line
                if (lineIndex > 0) {
                    // Use explicit BR element instead of newline character
                    element.appendChild(document.createElement('br'));
                }
            }

            if (charIndex < lines[lineIndex].length) {
                const textNode = document.createTextNode(lines[lineIndex][charIndex]);
                element.appendChild(textNode);
                charIndex++;
                setTimeout(type, speed);
            } else {
                // Move to next line
                lineIndex++;
                charIndex = 0;
                setTimeout(type, speed);
            }
        }
    }

    type();
}

// Content switching function
function showContent(section) {
    const contentMap = {
        'home': 'homeContent',
        'privacy': 'privacyContent',
        'contact': 'contactContent'
    };

    // Get current and new content elements
    const currentContent = document.querySelector('.terminal-content.active');
    const newContent = document.getElementById(contentMap[section]);

    if (currentContent === newContent) return;

    // Fade out current content
    currentContent.style.opacity = '0';

    // After fade out, switch content and start typing
    setTimeout(() => {
        currentContent.classList.remove('active');
        newContent.classList.add('active');
        newContent.style.opacity = '1';

        // Get text content and start typing animation
        const textElement = newContent.querySelector('.terminal-text');
        // Preserve original text formatting by getting textContent
        const originalText = textElement.textContent.trim();
        typeText(textElement, originalText);
    }, 300);
}

        // Initialize terminal
        document.addEventListener('DOMContentLoaded', () => {
            const terminal = document.querySelector('.glass-effect');
            terminal.classList.add('expanded');

            // Start initial typing animation
            const initialText = document.querySelector('.terminal-content.active .terminal-text');
            const originalText = initialText.textContent;
            typeText(initialText, originalText);
        });

        // Grid animation setup
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let gridSize = 40;
        const speed = 1;
        let offset = 0;

        const horizon = () => canvas.height * 0.4;
        const perspective = () => canvas.height * 1.5;
        const aspectRatio = () => canvas.width / canvas.height;
        const spreadFactor = () => 3.2 * aspectRatio();
        const numLines = () => Math.ceil((canvas.width / gridSize) * 2.5);

        function getVerticalLineOpacity(x, centerX) {
            const distance = Math.abs(x - centerX);
            const maxDistance = canvas.width / 2;
            return Math.max(0.15, Math.min(1, 1 - Math.pow(distance / maxDistance, 1.5)));
        }

        function getHorizontalLineOpacity(y, horizonY) {
            const distance = y - horizonY;
            const maxDistance = canvas.height - horizonY;
            const normalizedDistance = distance / maxDistance;
            return Math.max(0.2, Math.min(1, Math.pow(normalizedDistance, 1.5)));
        }
 function drawVignettes() {
            const maxDimension = Math.max(canvas.width, canvas.height);
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, maxDimension * 0.6
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.4, 'rgba(0,0,0,0.1)');
            gradient.addColorStop(0.6, 'rgba(0,0,0,0.4)');
            gradient.addColorStop(0.8, 'rgba(0,0,0,0.8)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.95)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const horizonY = horizon();
            ctx.save();

            ctx.beginPath();
            ctx.ellipse(
                canvas.width / 2,
                horizonY,
                canvas.width * 1.2,
                canvas.height * 0.35,
                0,
                0,
                Math.PI * 2
            );

            const ovalGradient = ctx.createRadialGradient(
                canvas.width / 2, horizonY, 0,
                canvas.width / 2, horizonY, canvas.width * 0.8
            );
            ovalGradient.addColorStop(0, 'rgba(0,0,0,0)');
            ovalGradient.addColorStop(0.2, 'rgba(0,0,0,0.1)');
            ovalGradient.addColorStop(0.4, 'rgba(0,0,0,0.4)');
            ovalGradient.addColorStop(0.7, 'rgba(0,0,0,0.7)');
            ovalGradient.addColorStop(1, 'rgba(0,0,0,0.9)');

            ctx.fillStyle = ovalGradient;
            ctx.fill();
            ctx.restore();

            const topGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            topGradient.addColorStop(0, 'rgba(0,0,0,1)');
            topGradient.addColorStop(0.33, 'rgba(0,0,0,1)');
            topGradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = topGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            gridSize = Math.max(20, Math.min(40, canvas.width / 25));

            const currentHorizon = horizon();
            const currentPerspective = perspective();
            const currentAspectRatio = aspectRatio();
            const currentSpreadFactor = spreadFactor();
            const currentNumLines = numLines();

            // Draw vertical lines
            for (let x = -currentNumLines; x <= currentNumLines; x++) {
                const spacing = gridSize;

                let startX = canvas.width / 2 + x * spacing * currentSpreadFactor;
                let startY = canvas.height * 1.5;

                let endX = canvas.width / 2 + x * (spacing / 6);
                let endY = currentHorizon;

                startX = canvas.width / 2 + (startX - canvas.width / 2) / (1 + (canvas.height - startY) / currentPerspective);

                const opacity = getVerticalLineOpacity(endX, canvas.width / 2);
                ctx.strokeStyle = `rgba(180, 190, 220, ${opacity * 0.5})`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Draw horizontal lines
            const numHorizontalLines = Math.ceil(canvas.height / gridSize) * 1.5;
            for (let z = 0; z < numHorizontalLines; z++) {
                const y = currentHorizon + (z * gridSize) + offset;
                if (y > canvas.height * 1.5) continue;

                const perspectiveFactor = 1 + (y - currentHorizon) / currentPerspective;
                const width = canvas.width * perspectiveFactor * currentSpreadFactor;

                const opacity = getHorizontalLineOpacity(y, currentHorizon);
                ctx.strokeStyle = `rgba(180, 190, 220, ${opacity * 0.5})`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 - width / 2, y);
                ctx.lineTo(canvas.width / 2 + width / 2, y);
                ctx.stroke();
            }

            drawVignettes();

            offset = (offset + speed) % gridSize;

            requestAnimationFrame(drawGrid);
        }

        drawGrid();
    </script>
</body>
</html>